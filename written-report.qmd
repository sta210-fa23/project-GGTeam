---
title: "Predicting Tik-Tok User Data Based on Video Data"
author: "GGteam: Will Chen, Katelyn Cai, Hannah Choi, Weston Slayton"
date: "Nov 9"
format: pdf
execute: 
  warning: false
  message: false
  echo: false
editor: visual
---

```{r}
#| label: load packages and data
#| warning: false
#| message: false
library(dplyr)
library(tidyverse)
library(tidymodels)
library(patchwork)
library(car)
library(knitr)
```

Below is a brief description of the sections to focus on in the draft:

```{r}
tiktok <- read.csv("data/top_users_vids.csv")
```

#### Introduction and data

This section includes an introduction to the project motivation, data, and research question. Describe the data and definitions of key variables. It should also include some exploratory data analysis. All of the EDA won't fit in the body of the report, so focus on the EDA for the response variable and a few other interesting variables and relationships.

```{r}
tiktok_users <- tiktok|>
  dplyr::group_by(user_name)|>
  dplyr::summarize(likes = mean(n_likes),
            shares = mean(n_shares),
            comments = mean(n_comments),
            plays = mean(n_plays),
            followers = mean(n_followers),
            video_length = mean(video_length),
            total_videos = mean(n_total_vids)) |>
  mutate(video_length_bin = ntile(video_length, n=3))
```

```{r}
tiktok_users |>
  ggplot(aes(x = followers)) + 
  geom_histogram() + 
  labs(x = "Followers", y = "Count", title = "Distribution of Number of Followers") + 
  scale_x_continuous(labels = label_number())
```

Since our data is heavily skewed, we continue our analysis by examining potential

```{r}
predictor_vars <- c("likes", "shares", "comments", "plays", "video_length", "total_videos")

create_individual_residual_plot <- function(predictor, data) {
  model <- linear_reg() |>
    set_engine("lm") |>
    fit(reformulate(predictor, response = "followers"), data = data)
  
  augmented_data <- augment(model$fit)
  
  ggplot(augmented_data, aes_string(x = ".fitted", y = ".resid")) +
    geom_point() +
    geom_hline(yintercept = 0, color = "red", linetype = "dashed") +
    labs(x = "Fitted Values", y = "Residuals", title = paste("Residuals vs Fitted for", predictor)) +
    theme_minimal()
}

individual_residual_plots <- map(predictor_vars, ~create_individual_residual_plot(.x, tiktok_users))
# from individual plots scaled to size, it's clear that constant variance is not met
# patchwork for visualization 
combined_plots <- reduce(individual_residual_plots, `+`)
final_plot <- combined_plots + plot_layout(ncol = 3, nrow = 2)
final_plot
```

```{r}
transformed_tiktok_users <- tiktok |>
  dplyr::group_by(user_name) |>
  dplyr::summarize(
    likes = mean(n_likes),
    shares = mean(n_shares),
    comments = mean(n_comments),
    plays = mean(n_plays),
    followers = mean(n_followers),
    video_length = mean(video_length),
    total_videos = mean(n_total_vids)
  ) |>
  mutate(video_length_bin = ntile(video_length, n = 3)) |>
  mutate(
    followers = log(followers + 1),
    shares = log(shares + 1),
    comments = log(comments + 1),
    plays = log(plays + 1),
    likes = log(likes + 1),
    total_videos = log(total_videos + 1)
  ) |>
  mutate_at(vars(followers, shares, comments, plays, likes, total_videos),
            scale)
```

#### Detecting Multicollinearity & Model Comparison

```{r}
tiktok_users_fit <- linear_reg() |>
  set_engine("lm")|>
  fit(followers ~ likes + shares + comments + plays + video_length_bin + total_videos, data=transformed_tiktok_users)
vif(tiktok_users_fit$fit)
```

```{r}
m1 <- linear_reg() |>
  set_engine("lm") |>
  fit(followers ~ . - likes - video_length- user_name, data = transformed_tiktok_users)
  
m1 |>
  tidy() |>
  kable(digits = 3)
```

```{r}
m2 <- linear_reg() |>
  set_engine("lm") |>
  fit(log(followers) ~ . - video_length - video_length_bin - user_name, data = transformed_tiktok_users)
  
m2 |>
  tidy() |>
  kable(digits = 3)
```

```{r}
glance(m1)|>
  select(adj.r.squared, AIC, BIC)
```

```{r}
glance(m2)|>
  select(adj.r.squared, AIC, BIC)
```

Based on AIC and BIC, model 2 (the model without video length bin) is a better fit. Therefore, we choose to remove video_length_bin from the model and leave likes in the model to deal with the multicollinearity.

```{r}
tiktok_aug <- augment(m2$fit)

ggplot(data = tiktok_aug, aes(x = .fitted, y = .resid)) +
    geom_point() +
    geom_hline(yintercept = 0, color = "red", linetype = "dashed") +
    labs(x = "Fitted values",
         y = "Residuals",
         title = "Residuals vs. fitted")

resid_hist <- ggplot(data = tiktok_aug, aes(x = .resid)) +
    geom_histogram() +
    labs(x = "Residuals",
         title = "Distribution of residuals")
  resid_hist
```

```{r}
ggplot(data = tiktok_aug, aes(x = likes, y = .resid)) +
    geom_point() +
    geom_hline(yintercept = 0, color = "red", linetype = "dashed") +
    labs(x = "Fitted values",
         y = "Residuals",
         title = "Residuals vs. fitted")

ggplot(data = tiktok_aug, aes(x = shares, y = .resid)) +
    geom_point() +
  coord_cartesian(xlim = c(0, 50)) +
    geom_hline(yintercept = 0, color = "red", linetype = "dashed") +
    labs(x = "Fitted values",
         y = "Residuals",
         title = "Residuals vs. fitted")

ggplot(data = tiktok_aug, aes(x = comments, y = .resid)) +
    geom_point() +
    coord_cartesian(xlim = c(0, 50)) +
    geom_hline(yintercept = 0, color = "red", linetype = "dashed") +
    labs(x = "Fitted values",
         y = "Residuals",
         title = "Residuals vs. fitted")

ggplot(data = tiktok_aug, aes(x = plays, y = .resid)) +
    geom_point() +
    geom_hline(yintercept = 0, color = "red", linetype = "dashed") +
    labs(x = "Fitted values",
         y = "Residuals",
         title = "Residuals vs. fitted")

ggplot(data = tiktok_aug, aes(x = total_videos, y = .resid)) +
    geom_point() +
  coord_cartesian(xlim = c(0, 50)) +
    geom_hline(yintercept = 0, color = "red", linetype = "dashed") +
    labs(x = "Fitted values",
         y = "Residuals",
         title = "Residuals vs. fitted")
```

```{r}
set.seed(29)

tiktok_split <- initial_split(tiktok_users, prop = 0.7)
tiktok_train <- training(tiktok_split)
tiktok_test  <- testing(tiktok_split)
```

```{r}
tiktok_rec <- recipe(followers ~ likes + shares + comments + plays + total_videos, 
                    data = tiktok_train) |>
  step_log(all_predictors()) |>
  step_log(followers) 

tiktok_spec <- linear_reg() |>
  set_engine("lm")

tiktok_wflow1 <- workflow() |>
  add_model(tiktok_spec) |>
  add_recipe(tiktok_rec)
```

```{r}

folds <- vfold_cv(tiktok_train, v = 10)

tiktok_cv1 <- tiktok_wflow1 |>
  fit_resamples(resamples = folds) 

collect_metrics(tiktok_cv1, summarize = TRUE)
```

```{r}

```

#### Methodology

This section includes a brief description of your modeling process. Explain the reasoning for the type of model you're fitting, predictor variables considered for the model including any interactions. Additionally, show how you arrived at the final model by describing the model selection process, any variable transformations (if needed), and any other relevant considerations that were part of the model fitting process.

#### Results

In this section, you will output the final model and include a brief discussion of the model assumptions, diagnostics, and any relevant model fit statistics.

This section also includes initial interpretations and conclusions drawn from the model.

Your written report goes here!

::: callout-important
Before you submit, make sure your code chunks are turned off with `echo: false` and there are no warnings or messages with `warning: false` and `message: false` in the YAML.
:::
